# 코드 리뷰 체크리스트

## 🎯 목적

코드 리뷰 시 놓치기 쉬운 부분들을 체계적으로 검증하여 일관된 코드 품질을 유지합니다.

📋 필수 체크리스트

## 1. 설계 및 구조 (Architecture & DRY)

[ ] 로직 중복 제거 (DRY): 동일하거나 유사한 로직이 3곳 이상 반복되는가?

✅ 해결: 공통 함수, 클래스, 또는 모듈로 추상화

[ ] 단일 책임 원칙 (SRP): 하나의 함수/클래스가 너무 많은 역할을 수행하지 않는가?

❌ 금지: 비즈니스 로직, 데이터 포맷팅, API 호출이 한 곳에 섞여 있음

✅ 해결: 계층(Layer) 분리 (예: Controller, Service, Repository)

[ ] 매직 넘버/스트링 사용: 코드 내에 의미를 알 수 없는 숫자나 문자열이 하드코딩 되어 있는가?

✅ 해결: 상수(Constant) 또는 열거형(Enum)으로 선언하여 의미 부여

## 2. 타입 및 데이터 무결성

[ ] 타입 안전성: any나 Object 같은 모호한 타입을 남용하지 않았는가?

❌ 금지: 컴파일러의 타입 체크를 우회하는 강제 형변환(Casting)

✅ 해결: 명시적인 인터페이스/DTO 정의 및 제네릭 활용

[ ] Null/Undefined 처리: 값이 없을 수 있는 상황(Nullable)에 대한 방어 로직이 있는가?

✅ 해결: Optional Chaining, Null 병합 연산자, 또는 명시적 Guard Clause 사용

[ ] 데이터 불변성: 데이터가 의도치 않게 변경(Mutation)되는 부작용(Side-effect)이 없는가?

✅ 해결: 데이터 복사본 사용 또는 불변 객체 패턴 활용

## 3. 에러 핸들링 및 안정성

[ ] 예외 처리 전략: catch 블록에서 에러를 단순히 삼키거나(swallow) 로그만 찍고 끝내지 않는가?

✅ 해결: 적절한 커스텀 에러로 래핑하여 상위로 전파하거나, 사용자에게 명확한 피드백 제공

[ ] 트랜잭션/상태 롤백: 작업 실패 시 데이터나 상태가 이전으로 안전하게 복구되는가?

✅ 해결: DB 트랜잭션 롤백, 메모리 상태 원복 로직 포함

[ ] 입력 값 검증: 함수나 API의 입력값이 예상 범위를 벗어날 경우를 처리했는가?

✅ 해결: 경계값 분석(Boundary Check), 유효성 검사 라이브러리 활용

## 4. 보안 (Security)

[ ] 민감 정보 노출: 코드에 API Key, 비밀번호, 토큰 등이 하드코딩 되어 있지 않은가?

✅ 해결: 환경 변수(.env) 또는 비밀 관리 도구(Secrets Manager) 사용

[ ] 인젝션 방지: SQL 인젝션이나 XSS 공격에 취약한 패턴이 없는가?

✅ 해결: 파라미터 바인딩(ORM 등) 사용, 사용자 입력 데이터 이스케이프 처리

[ ] 권한 체크: 리소스 접근 시 적절한 인가(Authorization) 로직이 수행되는가?

## 5. 가독성 및 컨벤션

[ ] 네이밍 일관성: 변수/함수명이 의도를 명확히 드러내며, 팀의 네이밍 규칙(CamelCase, Snake_case 등)을 따르는가?

✅ 체크: data, temp, info 같은 모호한 이름 지양

[ ] 폴더/파일 구조: 관련 있는 파일끼리 응집도 있게 그룹화되어 있는가?

[ ] 주석 및 문서화: 복잡한 비즈니스 로직이나 "왜(Why)" 이렇게 짰는지에 대한 설명이 필요한 곳에 주석이 있는가?

## 6. 성능 (Performance)

[ ] 불필요한 연산/조회: 반복문 안에서 DB 쿼리나 무거운 연산이 수행되지 않는가? (N+1 문제 등)

✅ 해결: 배치 처리, 쿼리 최적화, 메모이제이션(Caching) 활용

[ ] 리소스 누수: 파일 스트림, DB 커넥션, 이벤트 리스너가 사용 후 적절히 해제(Close/Dispose)되는가?

[ ] 비동기 처리: I/O 작업(DB, Network)이 메인 스레드를 차단(Blocking)하지 않는가?

## 7. 테스트 (Testing)

[ ] 테스트 커버리지: 주요 비즈니스 로직에 대한 단위 테스트(Unit Test)가 작성되었는가?

[ ] 엣지 케이스 테스트: 성공 케이스뿐만 아니라 실패/예외 상황에 대한 테스트가 포함되었는가?

## 8. 프론트엔드 특화 (React/Next.js)

### 컴포넌트 설계

[ ] **인라인 렌더링 로직**: JSX 내부의 복잡한 로직(맵핑, 조건부 렌더링)이 3회 이상 반복되는가?

- ✅ 해결: 별도 컴포넌트 또는 유틸 함수로 추출
- ❌ 금지: IIFE 패턴으로 복잡한 로직을 인라인 처리

[ ] **공용 컴포넌트 사용**: 모든 버튼이 `Button` 컴포넌트를 사용하는가?

- ❌ 금지: `<button className="...">` 직접 사용
- ✅ 해결: `@/components/ui/button`의 `Button` 컴포넌트 사용

[ ] **컴포넌트 분리**: 하나의 컴포넌트가 200줄 이상인가?

- ✅ 해결: 기능별로 분리 (예: `charts/`, `tables/`, `forms/`, `modals/`)

### React 훅 최적화

[ ] **useEffect cleanup**: 이벤트 리스너, 구독, 타이머가 cleanup 함수로 해제되는가?

- ✅ 해결: `useEffect`의 return 함수에서 cleanup

[ ] **의존성 배열**: `useEffect`, `useMemo`, `useCallback`의 의존성 배열이 정확한가?

- ❌ 금지: 빈 배열 `[]` 또는 의존성 누락으로 인한 stale closure

[ ] **불필요한 리렌더링**: props로 전달되는 함수가 `useCallback`으로 메모이제이션되었는가?

- ✅ 체크: 자식 컴포넌트에 함수 props 전달 시

### UI/UX 안전성

[ ] **경계 체크**: 절대 위치 요소(툴팁, 팝업)가 화면 밖으로 나갈 수 있는가?

- ✅ 해결: `window.innerWidth`, `window.innerHeight` 체크

[ ] **날짜/숫자 파싱**: 외부 입력(날짜, 숫자)을 파싱할 때 에러 처리가 있는가?

- ✅ 해결: `isNaN()`, `isValid()` 체크 후 기본값 반환

[ ] **빈 상태 처리**: 데이터가 없을 때 적절한 폴백이 있는가?

- ✅ 해결: `EmptyState` 컴포넌트 또는 안내 메시지

[ ] **로딩 상태**: 비동기 작업 중 로딩 인디케이터가 표시되는가?

- ✅ 해결: `Suspense` 또는 로딩 스피너

### 폴더 구조 (프론트엔드)

[ ] **논리적 그룹화**: 관련 컴포넌트들이 서브폴더로 그룹화되어 있는가?

- ✅ 예시: `charts/`, `tables/`, `forms/`, `modals/`

[ ] **Import 경로**: 상대 경로(`./`, `../`)가 적절히 사용되는가?

- ✅ 규칙: 같은 폴더 내는 `./`, 상위는 `../`, 절대 경로는 `@/`

[ ] **공용 타입**: 공용 타입이 적절한 위치에 정의되어 있는가?

- ✅ 규칙: 컴포넌트 공용은 `components/trades/types.ts`, 전역은 `lib/trades/types.ts`

[ ] **타입 중복 정의**: 동일한 인터페이스가 여러 파일에 정의되어 있는가?

- ✅ 해결: 공용 타입 파일(`types.ts`)로 통합

### Next.js 특화

[ ] **서버/클라이언트 분리**: `"use client"`가 필요한 곳에만 사용되는가?

- ❌ 금지: 서버 컴포넌트에서 불필요하게 클라이언트 컴포넌트로 변환

[ ] **데이터 페칭**: 서버 컴포넌트에서 직접 DB 쿼리를 사용하는가?

- ❌ 금지: 서버 컴포넌트에서 자체 API 라우트 호출
- ✅ 해결: `lib/trades/queries.ts` 같은 쿼리 함수 직접 사용

[ ] **에러 바운더리**: 에러 발생 시 적절한 에러 페이지가 표시되는가?

- ✅ 해결: `error.tsx` 파일 또는 `ErrorState` 컴포넌트

## 🔍 검증 프로세스

### 단계 1: 자동 검증

```bash
yarn lint        # ESLint 검사
yarn build       # 타입 체크 + 빌드
yarn test        # 테스트 실행
```

### 단계 2: 수동 체크리스트

위 체크리스트를 순서대로 확인

### 단계 3: 코드 리뷰

- PR 생성 전 자가 리뷰
- 변경된 파일 목록 확인
- 각 파일에 대해 체크리스트 적용

## 🚨 자주 놓치는 패턴 (프론트엔드)

### 패턴 1: 인라인 로직을 컴포넌트로 인식 못함

```tsx
// ❌ 나쁜 예: 인라인으로 복잡한 로직
{segments.map((seg) => {
  const offset = segments.slice(0, index).reduce(...);
  return <circle ... />;
})}

// ✅ 좋은 예: 별도 컴포넌트
<AssetAllocationChart segments={segments} />
```

### 패턴 2: 에러 발생 시 상태 롤백 없음

```tsx
// ❌ 나쁜 예
const handleSave = async () => {
  setValue(newValue); // 먼저 변경
  await api.save(); // 실패해도 롤백 없음
};

// ✅ 좋은 예
const handleSave = async () => {
  const previous = value;
  setValue(newValue);
  try {
    await api.save();
  } catch {
    setValue(previous); // 롤백
  }
};
```

### 패턴 3: Non-null assertion 남용

```tsx
// ❌ 나쁜 예
{
  formatPercent(getPercent(value)!, 1);
}

// ✅ 좋은 예
{
  percent !== null && formatPercent(percent, 1);
}
```

### 패턴 4: 공용 컴포넌트 미사용

```tsx
// ❌ 나쁜 예
<button className="px-3 py-1 rounded" onClick={...}>저장</button>

// ✅ 좋은 예
<Button onClick={...}>저장</Button>
```

## 9. 리팩토링 전용 체크리스트

리팩토링 작업 시 추가로 확인해야 할 항목들입니다. 위의 일반 체크리스트와 함께 검토하세요.

### 코드 구조

[ ] 책임 단위로 함수/클래스/모듈이 정리되어 있는가?

[ ] 파일 이름이 명확하고 일관적인가?

[ ] 중복 코드를 제거했는가?

### 가독성/스타일

[ ] 변수/함수 이름이 명확한가?

[ ] 복잡한 로직을 작은 단위로 쪼개고 테스트 가능한가?

[ ] 주석이 짧고 유용한가?

### 성능/확장성

[ ] 병목 구간이 보이는가?

[ ] 예상 스케일에 맞는 자료구조/알고리즘을 썼는가?

[ ] 비싼 연산을 최소화하거나 캐시했는가?

### 안정성/신뢰성

[ ] 엣지 케이스(null/빈 배열/타임아웃/에러) 처리가 있는가?

[ ] I/O·네트워크·DB는 재시도/타임아웃 등으로 보호되는가?

[ ] 필요한 곳에 트랜잭션/락을 썼는가?

### 테스트

[ ] 신규 동작이 단위/통합 테스트로 커버되는가?

[ ] 의미 있는 결과를 검증하는가(행복 경로만 아님)?

[ ] 빠르고 결정적으로 실행되는가?

### 의존성/설정

[ ] 새 의존성이 꼭 필요하고 최소한인가?

[ ] 설정/환경변수에 검증과 기본값이 있는가?

[ ] 마이그레이션/스키마 변경이 적용·문서화 되었는가?

### UX/UI

[ ] 상태/로딩/에러를 우아하게 처리하는가?

[ ] 레이아웃이 반응형/접근성을 고려했는가?

[ ] 인터랙션이 예측 가능하고 일관적인가?

## 🔗 관련 문서

- [프론트엔드 품질 원칙](./FRONTEND_PRACTICES.md)
- [테스트 가이드](./TESTING.md)
- [피쳐 개발 워크플로우](./FEATURE_DEVELOPMENT_WORKFLOW.md) (3단계 검증 프로세스 포함)
