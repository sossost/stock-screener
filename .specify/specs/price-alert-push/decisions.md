# 가격 알림 시스템 (푸시 알림) - 의사결정 기록 (ADR)

이 문서는 가격 알림 시스템 (푸시 알림) 개발 과정에서 내린 주요 의사결정과 그 근거를 기록합니다.

**범위**: Phase 3 (푸시 알림) 구현 단계의 모든 의사결정을 포함합니다.

## ADR-014: 푸시 알림 서비스 선택 - Expo Push Notification Service vs EAS Push

**날짜**: 2025-12-03  
**상태**: ✅ 채택  
**결정자**: 개발팀  
**단계**: 구현

### 상황

모바일 앱 푸시 알림을 전송하기 위한 서비스를 선택해야 했습니다.

### 고려 사항

**옵션 1**: Expo Push Notification Service
- ✅ Expo 공식 서비스로 통합 용이
- ✅ 무료 티어 제공
- ✅ iOS/Android 모두 지원
- ✅ 설정이 간단 (`expo-server-sdk` 설치만으로 사용 가능)
- ✅ 별도의 인증 토큰 불필요 (기본 서비스)
- ❌ 무료 티어 제한 (하루 1,000건)

**옵션 2**: EAS Push Notifications
- ✅ 더 높은 신뢰성 및 성능
- ✅ 더 높은 전송 한도
- ✅ 고급 기능 제공
- ❌ `EXPO_ACCESS_TOKEN` 필요 (추가 설정)
- ❌ 초기 단계에서는 과도한 복잡성

**옵션 3**: Firebase Cloud Messaging (FCM) 직접 사용
- ✅ 높은 신뢰성 및 확장성
- ✅ 무료 티어 제공
- ❌ Expo와의 통합이 복잡
- ❌ iOS/Android 각각 설정 필요
- ❌ 초기 설정 시간 소요

### 결정

**옵션 1 (Expo Push Notification Service) 채택**: 간단한 설정과 Expo 생태계 통합으로 빠른 구현 가능.

### 근거

1. **빠른 구현**: Expo 앱이므로 Expo 서비스를 사용하는 것이 가장 간단
2. **무료 티어**: 초기 단계에서 충분한 무료 티어 제공 (하루 1,000건)
3. **통합 용이성**: `expo-server-sdk`와 `expo-notifications`로 백엔드/프론트엔드 모두 간단히 통합 가능
4. **향후 확장성**: 필요 시 EAS Push로 업그레이드 가능

### 결과

- `expo-server-sdk` 패키지 설치 (`apps/web/package.json`)
- `Expo` 클라이언트 초기화 (`apps/web/src/lib/notifications/push.ts`)
- 향후 필요 시 `EXPO_ACCESS_TOKEN` 설정으로 EAS Push로 업그레이드 가능

---

## ADR-015: 알림 전송 전략 - 동기 전송 vs 비동기 큐

**날짜**: 2025-12-03  
**상태**: ✅ 채택  
**결정자**: 개발팀  
**단계**: 구현

### 상황

ETL에서 푸시 알림을 전송하는 방식을 결정해야 했습니다.

### 고려 사항

**옵션 1**: 동기 전송 (ETL에서 직접 전송)
- ✅ 구현이 간단
- ✅ 즉시 전송 확인 가능
- ✅ 에러 처리 직관적
- ❌ ETL 실행 시간 증가 가능
- ❌ 전송 실패 시 ETL 재실행 필요

**옵션 2**: 비동기 큐 (BullMQ, Redis Queue)
- ✅ ETL 블로킹 없음
- ✅ 재시도 로직, 우선순위 큐 지원
- ✅ 확장성 높음
- ❌ 추가 인프라 필요 (Redis)
- ❌ 구현 복잡도 증가
- ❌ 초기 단계에서는 과도한 복잡성

### 결정

**옵션 1 (동기 전송) 채택**: MVP 단계에서는 간단한 구현이 우선. 향후 필요 시 큐로 전환 가능.

### 근거

1. **MVP 우선**: 초기 단계에서는 기능 구현에 집중
2. **간단한 에러 처리**: 타임아웃 및 재시도 로직으로 충분한 안정성 확보
3. **ETL 영향 최소화**: 푸시 알림 전송은 빠르게 완료되므로 ETL 지연 최소
4. **향후 확장성**: 필요 시 큐 시스템으로 전환 가능한 구조로 설계

### 결과

- ETL에서 직접 `sendPushNotificationBatch()` 호출 (`apps/web/src/etl/jobs/detect-price-alerts.ts`)
- 타임아웃(10초) 및 재시도 로직(지수 백오프) 적용
- 전송 실패 시 로깅만 하고 ETL은 계속 진행 (Graceful Degradation)

---

## ADR-016: 디바이스 토큰 관리 전략 - 데이터베이스 테이블 vs 메모리 캐시

**날짜**: 2025-12-03  
**상태**: ✅ 채택  
**결정자**: 개발팀  
**단계**: 구현

### 상황

디바이스 토큰을 저장하고 관리하는 방식을 결정해야 했습니다.

### 고려 사항

**옵션 1**: 데이터베이스 테이블
- ✅ 영구 저장, 서버 재시작 후에도 유지
- ✅ 조회 및 관리 용이
- ✅ UNIQUE 제약으로 중복 방지
- ✅ 활성/비활성 상태 관리 가능
- ✅ 향후 사용자별 관리 확장 용이
- ❌ 데이터베이스 쿼리 오버헤드

**옵션 2**: 메모리 캐시 (Redis, In-Memory)
- ✅ 빠른 조회 성능
- ✅ 서버 재시작 시 자동 초기화 (오래된 토큰 정리)
- ❌ 서버 재시작 시 모든 토큰 손실
- ❌ 확장성 낮음 (여러 서버 인스턴스 시 동기화 필요)
- ❌ 영구 저장 불가

### 결정

**옵션 1 (데이터베이스 테이블) 채택**: 영구 저장과 확장성을 고려한 선택.

### 근거

1. **영구 저장**: 서버 재시작 후에도 토큰 유지 (사용자 경험 개선)
2. **확장성**: 향후 사용자별 알림 설정, 다중 디바이스 지원 등 확장 용이
3. **관리 용이성**: 활성/비활성 상태 관리, 중복 방지 등 관리 기능 제공
4. **성능**: 디바이스 토큰 조회는 빈번하지 않으므로 DB 오버헤드 허용 가능

### 결과

- `device_tokens` 테이블 생성 (`apps/web/src/db/schema.ts`)
- `device_id`에 UNIQUE 제약 적용 (중복 방지)
- `is_active` 필드로 활성/비활성 상태 관리
- 향후 `user_id` 필드로 사용자별 관리 확장 가능

---

## ADR-017: 알림 형식 선택 - 개별 알림 vs 종합 알림

**날짜**: 2025-12-03  
**상태**: ✅ 채택  
**결정자**: 개발팀  
**단계**: 구현

### 상황

여러 종목이 동시에 돌파 조건을 만족할 때 푸시 알림을 어떻게 전송할지 결정해야 했습니다.

### 고려 사항

**옵션 1**: 개별 알림 (종목당 1개 알림)
- ✅ 각 종목에 대한 상세 정보 제공
- ✅ 사용자가 원하는 종목만 확인 가능
- ❌ 알림 스팸 (35개 종목 = 35개 알림)
- ❌ 사용자 경험 저하 (알림 폭탄)
- ❌ 디바이스 알림 설정에서 차단 가능성

**옵션 2**: 종합 알림 (여러 종목 → 1개 알림)
- ✅ 사용자 경험 개선 (1개 알림만 수신)
- ✅ 알림 스팸 방지
- ✅ 요약 정보 제공 (종목 수, 조건 등)
- ❌ 개별 종목 상세 정보 부족
- ✅ 상세 정보는 앱에서 API로 조회 가능

### 결정

**옵션 2 (종합 알림) 채택**: 사용자 경험을 우선시하고, 상세 정보는 앱에서 조회하도록 설계.

### 근거

1. **사용자 경험**: 35개 알림보다 1개 종합 알림이 훨씬 나은 사용자 경험
2. **알림 스팸 방지**: 사용자가 알림을 차단하지 않도록 방지
3. **상세 정보 접근**: 앱에서 알림을 받으면 API로 상세 정보 조회 가능
4. **이메일과 일관성**: 이메일 알림도 종합 형식이므로 일관성 유지

### 결과

- 여러 종목이 감지되어도 1개의 종합 푸시 알림만 전송
- 제목: `가격 알림: N개 종목 20일선 돌파 감지`
- 본문: `조건: 정배열 상태에서 20일선 돌파`
- `data` 필드에 `alertCount`, `date`, `threadId` 포함
- 향후 앱에서 `/api/alerts?date={date}` API로 상세 정보 조회 가능

---

## ADR-018: 푸시 알림 데이터 필드 최소화 - 메시지 크기 제한 고려

**날짜**: 2025-12-03  
**상태**: ✅ 채택  
**결정자**: 개발팀  
**단계**: 구현 (버그 수정)

### 상황

35개 종목의 상세 정보를 `data` 필드에 포함했더니 푸시 알림이 수신되지 않는 문제가 발생했습니다.

### 고려 사항

**옵션 1**: 모든 종목 상세 정보 포함 (`alerts` 배열)
- ✅ 앱에서 추가 API 호출 불필요
- ✅ 오프라인에서도 상세 정보 확인 가능
- ❌ 메시지 크기 제한 초과 (35개 × 약 200바이트 ≈ 7KB > 4KB 제한)
- ❌ Expo 서버는 OK를 반환하지만 실제 알림 미수신

**옵션 2**: 최소한의 정보만 포함 (요약 정보)
- ✅ 메시지 크기 제한 준수 (약 200바이트)
- ✅ 알림 수신 보장
- ✅ 상세 정보는 앱에서 API로 조회
- ❌ 추가 API 호출 필요

### 결정

**옵션 2 (최소한의 정보만 포함) 채택**: 메시지 크기 제한을 준수하여 알림 수신을 보장.

### 근거

1. **알림 수신 보장**: 메시지 크기 제한 초과 시 알림이 수신되지 않으므로 최우선 고려
2. **Expo 제한**: Expo Push Notification Service는 약 4KB 크기 제한
3. **상세 정보 접근**: 앱에서 API로 조회하는 것이 더 유연하고 확장 가능
4. **네트워크 효율**: 알림은 경량으로 유지하고, 필요 시에만 상세 정보 조회

### 결과

- `data` 필드에서 `alerts` 배열 제거
- 최소한의 정보만 포함: `alertType`, `date`, `alertCount`, `threadId`
- 메시지 크기: 약 200바이트 (제한 내)
- 앱에서 알림 수신 시 `/api/alerts?date={date}` API로 상세 정보 조회
- 알림 수신 문제 해결 확인

---

## ADR-019: 푸시 알림 형식 - 이메일과 동일한 형식 사용

**날짜**: 2025-12-03  
**상태**: ✅ 채택  
**결정자**: 개발팀  
**단계**: 구현

### 상황

푸시 알림의 제목과 본문 형식을 결정해야 했습니다.

### 고려 사항

**옵션 1**: 이메일과 동일한 형식
- ✅ 일관성 있는 사용자 경험
- ✅ 사용자가 두 채널에서 동일한 정보 인지
- ✅ 유지보수 용이 (형식 변경 시 한 곳만 수정)
- ✅ 브랜드 일관성

**옵션 2**: 푸시 알림 전용 형식
- ✅ 푸시 알림 특성에 최적화 (짧고 간결)
- ❌ 이메일과 다른 형식으로 혼란 가능
- ❌ 두 가지 형식 유지보수 필요

### 결정

**옵션 1 (이메일과 동일한 형식) 채택**: 일관성 있는 사용자 경험 제공.

### 근거

1. **일관성**: 사용자가 이메일과 푸시 알림에서 동일한 정보를 인지
2. **유지보수**: 형식 변경 시 한 곳만 수정하면 됨
3. **브랜드 일관성**: 모든 알림 채널에서 일관된 메시지 전달
4. **단순성**: 복잡한 형식 변환 로직 불필요

### 결과

- 제목: `가격 알림: N개 종목 20일선 돌파 감지` (이메일과 동일)
- 본문: `조건: 정배열 상태에서 20일선 돌파` (이메일과 동일)
- 향후 형식 변경 시 `email.ts`와 `push.ts` 모두 업데이트 필요

---

## 향후 의사결정 예상 항목

### ADR-020 (예정): 알림 클릭 시 상세 화면 이동

**예상 시점**: Phase 4 (앱 UI 개선)

**고려 사항**:
- 알림 클릭 시 상세 화면으로 이동하는 방법
- 라우팅 처리 (React Navigation vs Expo Router)
- 딥링크 처리

**예상 결정**: Expo Router를 사용하여 `/stock/{symbol}` 경로로 이동

---

### ADR-021 (예정): 알림 조회 API 구현

**예상 시점**: Phase 4 (앱 UI 개선)

**고려 사항**:
- 알림 이력 조회 API 엔드포인트
- 읽음/삭제 기능
- 페이지네이션

**예상 결정**: `/api/notifications/alerts` 엔드포인트 구현

---

### ADR-022 (예정): 비동기 큐로 전환

**예상 시점**: 확장 단계 (알림량 증가 시)

**고려 사항**:
- BullMQ vs Redis Queue
- 재시도 로직
- 우선순위 큐

**예상 결정**: 알림량이 증가하면 BullMQ로 전환

---

## 의사결정 프로세스

1. **상황 파악**: 문제 또는 선택지 명확히 정의
2. **옵션 나열**: 가능한 모든 옵션과 장단점 정리
3. **근거 수립**: 프로젝트 원칙, 일관성, 실용성 등을 고려
4. **결정 문서화**: ADR 형식으로 기록
5. **결과 추적**: 결정 후 실제 결과 확인 및 필요 시 수정

## 참고 자료

- [ADR 템플릿](https://adr.github.io/)
- 프로젝트 원칙: `docs/CODE_REVIEW_CHECKLIST.md`
- 이메일 알림 의사결정: `.specify/specs/price-alert-email/decisions.md`
- Expo Push Notification Service: https://docs.expo.dev/push-notifications/overview/

