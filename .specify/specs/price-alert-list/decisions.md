# 가격 알림 목록 페이지 - 의사결정 기록 (ADR)

가격 알림 목록 페이지 개발 과정에서 내린 주요 의사결정과 그 근거를 기록합니다.

## ADR-001: 테이블 데이터 구조 - ScreenerCompany 재사용

### 상황

알림 종목들을 표시할 테이블의 데이터 구조를 결정해야 함.

### 고려 사항

**옵션 1**: 스크리너 테이블과 동일한 `ScreenerCompany` 타입 사용
- ✅ 기존 컴포넌트(`StockTable`) 재사용 가능
- ✅ 일관된 UI/UX
- ✅ 유지보수 용이 (컬럼 변경 시 한 곳만 수정)
- ❌ 알림 데이터를 `ScreenerCompany`로 변환하는 로직 필요

**옵션 2**: 알림 전용 타입(`AlertListItem`) 생성
- ✅ 알림에 특화된 데이터 구조
- ✅ 변환 로직 불필요
- ❌ 기존 컴포넌트 재사용 불가
- ❌ 중복 코드 발생 (테이블 컴포넌트, 컬럼 정의 등)

### 결정

**옵션 1 채택**: `ScreenerCompany` 타입을 재사용하고, 알림 데이터를 변환하는 로직 구현.

### 근거

1. **DRY 원칙**: 기존 컴포넌트와 로직 재사용으로 중복 제거
2. **일관성**: 사용자가 동일한 테이블 형태로 정보를 확인할 수 있어 학습 비용 감소
3. **유지보수성**: 컬럼 추가/변경 시 한 곳만 수정하면 됨
4. **구현 속도**: 기존 컴포넌트 재사용으로 빠른 구현 가능

### 결과

- API에서 알림 종목들을 `ScreenerCompany` 형태로 변환하여 반환
- `StockTable` 컴포넌트를 그대로 재사용
- 변환 로직은 `/api/alerts` 엔드포인트에 구현

---

## ADR-002: 날짜별 그룹화 방식 - 세로 배치

### 상황

날짜별로 알림을 그룹화하여 표시하는 방식을 결정해야 함.

### 고려 사항

**옵션 1**: 날짜별로 테이블을 세로로 배치 (최신 날짜부터 5거래일치)
- ✅ 날짜별로 명확하게 구분
- ✅ 각 날짜별로 독립적인 정렬/필터링 가능
- ✅ 스크롤 시 날짜 컨텍스트 유지
- ❌ 페이지가 길어질 수 있음

**옵션 2**: 단일 테이블에 날짜 컬럼 추가
- ✅ 컴팩트한 레이아웃
- ✅ 날짜별 정렬 가능
- ❌ 날짜별 그룹화가 명확하지 않음
- ❌ 같은 날짜의 알림들이 분산됨

**옵션 3**: 탭/드롭다운으로 날짜 선택
- ✅ 컴팩트한 레이아웃
- ✅ 한 번에 하나의 날짜만 표시
- ❌ 여러 날짜를 동시에 비교하기 어려움

### 결정

**옵션 1 채택**: 최신 날짜부터 5거래일치를 날짜별로 테이블을 세로로 배치.

### 근거

1. **명확성**: 날짜별로 명확하게 구분되어 가독성 향상
2. **비교 용이성**: 여러 날짜의 알림을 동시에 비교 가능
3. **컨텍스트 유지**: 스크롤해도 날짜 정보가 항상 보임
4. **사용자 요구사항**: 사용자가 명시적으로 요청한 방식

### 결과

- 각 날짜별로 날짜 헤더와 테이블을 세로로 배치
- 최신 날짜부터 최대 5거래일치만 표시
- 각 날짜별 테이블은 독립적으로 정렬/필터링 가능

---

## ADR-003: 데이터 변환 전략 - 해당 날짜 기준 조회

### 상황

`price_alerts` 테이블의 알림 데이터를 `ScreenerCompany` 형태로 변환해야 함. `condition_data` (JSONB)에는 일부 정보만 저장되어 있음.

### 고려 사항

**옵션 1**: 해당 날짜(`alert_date`) 기준으로 모든 관련 테이블에서 데이터 조회
- ✅ 정확한 데이터 (해당 날짜의 실제 데이터)
- ✅ `ScreenerCompany`에 필요한 모든 필드 조회 가능
- ❌ 복잡한 조인 쿼리 필요
- ❌ 성능 고려 필요

**옵션 2**: `condition_data`에서 가능한 데이터만 사용하고 나머지는 null/기본값
- ✅ 간단한 구현
- ✅ 빠른 쿼리
- ❌ 불완전한 데이터 (rs_score, pe_ratio, quarterly_financials 등 누락)
- ❌ 스크리너 테이블과 다른 데이터 표시

**옵션 3**: 최신 날짜 데이터 사용 (alert_date 무시)
- ✅ 간단한 쿼리
- ❌ 알림 발생 시점의 데이터가 아닌 현재 데이터 표시
- ❌ 의도와 다른 정보 제공

### 결정

**옵션 1 채택**: 해당 날짜(`alert_date`) 기준으로 모든 관련 테이블에서 데이터를 조회하여 완전한 `ScreenerCompany` 데이터 생성.

### 근거

1. **정확성**: 알림 발생 시점의 실제 데이터를 표시해야 함
2. **일관성**: 스크리너 테이블과 동일한 데이터 구조 유지
3. **신뢰성**: 사용자가 알림 받은 시점의 정보를 확인할 수 있어야 함
4. **확장성**: 향후 알림 효과 분석 등에 활용 가능

### 결과

- `/api/alerts` 엔드포인트에서 복잡한 조인 쿼리 구현
- `watchlist` API의 쿼리 패턴 참고하여 구현
- 각 날짜별로 해당 날짜의 데이터를 조회하여 `ScreenerCompany` 형태로 변환

---

## ADR-004: 날짜 수 제한 - 5거래일치

### 상황

표시할 날짜 수를 결정해야 함.

### 고려 사항

**옵션 1**: 최대 5거래일치
- ✅ 적절한 정보량 (너무 많지도 적지도 않음)
- ✅ 페이지 로딩 시간 적절
- ✅ 최근 알림에 집중

**옵션 2**: 제한 없음 (모든 날짜)
- ✅ 모든 알림 이력 확인 가능
- ❌ 페이지가 매우 길어짐
- ❌ 성능 저하 가능

**옵션 3**: 사용자 선택 (10/20/30일 등)
- ✅ 유연성
- ❌ 초기 구현 복잡도 증가

### 결정

**옵션 1 채택**: 최신 날짜부터 최대 5거래일치만 표시.

### 근거

1. **사용자 요구사항**: 사용자가 명시적으로 요청
2. **성능**: 적절한 데이터량으로 빠른 로딩
3. **집중도**: 최근 알림에 집중하여 실용적
4. **확장성**: 향후 페이지네이션 추가 가능

### 결과

- API에서 최신 날짜부터 최대 5거래일치만 조회
- 쿼리 파라미터로 `maxDates` 옵션 제공 (기본값: 5)

---

## ADR-005: 알림 타입 필터링 - 상단 탭 방식

### 상황

여러 알림 타입이 있을 때 사용자가 원하는 알림만 볼 수 있도록 필터링 기능 필요.

### 고려 사항

**옵션 1**: 페이지 상단에 FilterTabs로 알림 타입 선택
- ✅ 명확한 UI (탭으로 선택 상태가 명확)
- ✅ 여러 알림 타입 확장 용이
- ✅ 사용자 경험 일관성 (스크리너 페이지와 유사)
- ❌ 알림 타입이 많아지면 탭이 길어짐

**옵션 2**: 드롭다운 선택
- ✅ 공간 효율적
- ❌ 선택 상태가 덜 명확
- ❌ 모바일에서 사용성 저하

**옵션 3**: 날짜별로 알림 타입 표시 (배지)
- ❌ 필터링 기능 없음
- ❌ 중복 표시 (필터로 이미 선택됨)

### 결정

**옵션 1 채택**: 페이지 상단에 FilterTabs로 알림 타입 선택, 날짜 헤더 옆의 알림 타입 배지 제거.

### 근거

1. **명확성**: 선택한 알림 타입이 탭으로 명확히 표시됨
2. **일관성**: 스크리너 페이지의 필터 UI와 일관된 패턴
3. **확장성**: 새로운 알림 타입 추가 시 자동으로 탭에 반영
4. **중복 제거**: 날짜 헤더 옆 배지는 불필요 (필터로 이미 선택됨)

### 결과

- 페이지 상단에 FilterTabs 컴포넌트로 알림 타입 선택
- 선택한 알림 타입에 따라 API 호출
- 날짜별 Card로 구분하여 표시
- 날짜 헤더 옆 알림 타입 배지 제거

---

## ADR-006: 레이아웃 구조 - 날짜별 Card 구분

### 상황

날짜별로 알림을 표시할 때 레이아웃 구조를 결정해야 함.

### 고려 사항

**옵션 1**: 각 날짜별로 독립적인 Card로 구분
- ✅ 날짜별로 명확하게 구분
- ✅ 시각적으로 깔끔함
- ✅ 각 날짜별 독립적인 공간
- ❌ Card 패딩으로 인한 공간 사용

**옵션 2**: 단일 Card에 날짜별로 구분
- ✅ 컴팩트한 레이아웃
- ❌ 날짜 구분이 덜 명확
- ❌ 필터 위치가 Card 안에 있어 부적절

### 결정

**옵션 1 채택**: 각 날짜별로 독립적인 Card로 구분, 필터는 Card 밖 상단에 배치.

### 근거

1. **명확성**: 날짜별로 명확하게 구분되어 가독성 향상
2. **필터 위치**: 필터는 전체 데이터에 적용되므로 Card 밖 상단이 적절
3. **일관성**: 다른 페이지(스크리너, 관심종목)와 유사한 레이아웃 패턴
4. **사용자 경험**: 날짜별로 독립적인 Card로 구분되어 스크롤 시에도 구분이 명확

### 결과

- 필터는 페이지 상단(Card 밖)에 배치
- 각 날짜별로 독립적인 Card로 구분
- CardContent 상단 패딩 최적화 (pt-4)

