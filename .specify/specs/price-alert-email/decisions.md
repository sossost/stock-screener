# 가격 알림 시스템 (이메일) - 의사결정 기록 (ADR)

이 문서는 가격 알림 시스템 (이메일) 개발 과정에서 내린 주요 의사결정과 그 근거를 기록합니다.

**범위**: Phase 2 (이메일 알림 전송) 구현 단계의 모든 의사결정을 포함합니다.

## ADR-006: 이메일 서비스 선택 - Resend vs AWS SES vs SendGrid

**날짜**: 2025-12-03  
**상태**: ✅ 채택  
**결정자**: 개발팀  
**단계**: 구현

### 상황

이메일 알림 전송을 위한 이메일 서비스를 선택해야 했습니다.

### 고려 사항

**옵션 1**: Resend
- ✅ Next.js 공식 파트너
- ✅ 간단한 API, 무료 티어 제공 (월 3,000건)
- ✅ 트랜잭션 이메일 특화
- ✅ TypeScript 지원 우수
- ✅ 설정이 매우 간단
- ❌ 무료 티어 제한 (월 3,000건)

**옵션 2**: AWS SES
- ✅ 매우 저렴한 비용 ($0.10 per 1,000 emails)
- ✅ 높은 신뢰성 및 확장성
- ✅ AWS 인프라와 통합 용이
- ❌ 설정이 복잡 (도메인 인증, SES 샌드박스 등)
- ❌ 초기 설정 시간 소요

**옵션 3**: SendGrid
- ✅ 널리 사용되는 서비스
- ✅ 무료 티어 제공 (월 100건)
- ✅ 다양한 기능 제공
- ❌ 무료 티어가 매우 제한적
- ❌ API가 다소 복잡

### 결정

**옵션 1 (Resend) 채택**: 간단한 설정과 Next.js 친화적 API로 빠른 구현 가능.

### 근거

1. **빠른 구현**: 설정이 간단하여 Phase 2 목표 달성에 집중 가능
2. **Next.js 친화성**: Next.js 공식 파트너로 통합 용이
3. **무료 티어**: 초기 단계에서 충분한 무료 티어 제공 (월 3,000건)
4. **TypeScript 지원**: 타입 안전성 보장
5. **확장 가능성**: 필요 시 AWS SES 등으로 전환 가능

### 결과

- `resend` 패키지 설치
- `lib/notifications/email.ts`에서 Resend 사용
- 환경 변수: `RESEND_API_KEY` 설정

---

## ADR-007: 이메일 전송 전략 - 동기 전송 vs 비동기 큐

**날짜**: 2025-12-03  
**상태**: ✅ 채택 (초기 구현)  
**결정자**: 개발팀  
**단계**: 구현

### 상황

ETL에서 이메일을 전송하는 방식에 대한 선택이 필요했습니다.

### 고려 사항

**옵션 1**: 동기 전송 (초기 구현)
- ✅ 구현이 매우 간단
- ✅ 추가 인프라 불필요 (Redis, Queue 등)
- ✅ 즉시 에러 확인 가능
- ❌ ETL 실행 시간 증가 가능
- ❌ 이메일 전송 실패 시 ETL 실패 가능성

**옵션 2**: 비동기 큐 (BullMQ, Redis Queue)
- ✅ ETL 실행 시간에 영향 없음
- ✅ 재시도 로직 구현 용이
- ✅ 우선순위 큐, 배치 처리 가능
- ❌ 추가 인프라 필요 (Redis)
- ❌ 구현 복잡도 증가
- ❌ Phase 2 범위 초과

### 결정

**옵션 1 채택 (초기 구현)**: 동기 전송으로 시작하고, 향후 필요 시 비동기 큐로 전환.

### 근거

1. **MVP 우선**: Phase 2 목표는 이메일 전송 기능 구현이므로 최소 기능으로 시작
2. **단순성**: 추가 인프라 없이 빠르게 구현 가능
3. **에러 처리**: try-catch로 개별 알림 실패 시에도 ETL 계속 진행 가능
4. **확장 가능성**: 향후 트래픽 증가 시 비동기 큐로 전환 가능

### 결과

- ETL에서 직접 `sendEmailAlert()` 호출
- 개별 알림 전송 실패 시 로깅 후 다음 알림 계속 처리
- 향후 비동기 큐 전환을 위한 주석 추가

---

## ADR-008: 이메일 템플릿 - HTML vs 템플릿 엔진

**날짜**: 2025-12-03  
**상태**: ✅ 채택  
**결정자**: 개발팀  
**단계**: 구현

### 상황

이메일 본문을 생성하는 방식에 대한 선택이 필요했습니다.

### 고려 사항

**옵션 1**: 인라인 HTML 문자열
- ✅ 추가 의존성 없음
- ✅ 간단한 구현
- ✅ 빠른 개발
- ❌ 유지보수 어려움 (복잡한 템플릿 시)
- ❌ 반복되는 HTML 코드

**옵션 2**: 템플릿 엔진 (React Email, MJML 등)
- ✅ 재사용 가능한 컴포넌트
- ✅ 타입 안전성
- ✅ 유지보수 용이
- ❌ 추가 의존성 및 설정 필요
- ❌ Phase 2 범위 초과

### 결정

**옵션 1 채택**: 인라인 HTML 문자열로 시작하고, 향후 복잡도 증가 시 템플릿 엔진 도입 검토.

### 근거

1. **단순성**: Phase 2에서는 간단한 알림 템플릿만 필요
2. **빠른 구현**: 추가 설정 없이 즉시 구현 가능
3. **확장 가능성**: 향후 템플릿이 복잡해지면 React Email 등으로 전환 가능

### 결과

- `formatEmailTemplate()` 함수로 HTML 문자열 생성
- 향후 템플릿 엔진 도입을 위한 주석 추가

---

## ADR-009: 환경 변수 관리 - 필수 vs 선택사항

**날짜**: 2025-12-03  
**상태**: ✅ 채택  
**결정자**: 개발팀  
**단계**: 구현

### 상황

이메일 관련 환경 변수를 필수로 할지 선택사항으로 할지 결정해야 했습니다.

### 고려 사항

**옵션 1**: 필수 환경 변수 (없으면 에러)
- ✅ 명확한 설정 요구사항
- ✅ 빠른 실패 (Fail Fast)
- ❌ 개발 환경에서 이메일 설정 없이 테스트 어려움

**옵션 2**: 선택사항 (없으면 스킵)
- ✅ 개발 환경에서 유연성
- ✅ 이메일 설정 없이도 ETL 실행 가능
- ❌ 설정 누락 시 조용히 실패 가능

**옵션 3**: 환경 변수 검증 후 조건부 실행 (최종 결정)
- ✅ 명확한 설정 요구사항
- ✅ 개발 환경에서 유연성
- ✅ 환경 변수 누락 시 명확한 로그

### 결정

**옵션 3 채택**: 환경 변수 검증 후, 없으면 이메일 전송 스킵하고 로깅만 수행.

### 근거

1. **개발 편의성**: 개발 환경에서 이메일 설정 없이도 테스트 가능
2. **명확성**: 환경 변수 누락 시 명확한 로그 출력
3. **유연성**: 프로덕션에서는 필수, 개발에서는 선택사항으로 운영 가능

### 결과

- 환경 변수 검증 로직 추가
- 누락 시 경고 로그 및 이메일 전송 스킵
- `.env.example`에 필수 변수 명시

---

## ADR-010: 이메일 수신자 관리 - 환경 변수 vs 데이터베이스 vs API

**날짜**: 2025-12-03  
**상태**: ✅ 채택  
**결정자**: 개발팀  
**단계**: 구현

### 상황

이메일 알림의 보내는 사람(`FROM`)과 받는 사람(`TO`)을 어떻게 관리할지 결정해야 했습니다.

### 고려 사항

**옵션 1**: 환경 변수로 관리 (최종 결정)
- ✅ 구현이 매우 간단
- ✅ 코드 변경 없이 수신자 변경 가능
- ✅ 환경별(개발/프로덕션)로 다른 수신자 설정 가능
- ✅ 초기 단계에서 충분한 유연성
- ❌ 사용자별 알림 설정 불가 (모든 사용자가 동일한 알림 수신)
- ❌ 동적 수신자 변경 불가 (환경 변수 변경 후 재시작 필요)

**옵션 2**: 데이터베이스 테이블로 관리
- ✅ 사용자별 알림 설정 가능
- ✅ 동적 수신자 변경 가능 (코드 재배포 불필요)
- ✅ 알림 구독/해지 기능 구현 가능
- ❌ 초기 구현 복잡도 증가
- ❌ 사용자 인증 시스템 필요
- ❌ Phase 2 범위 초과

**옵션 3**: API로 수신자 전달
- ✅ 유연한 수신자 지정
- ❌ ETL에서 API 호출 필요 (복잡도 증가)
- ❌ 수신자 목록 관리 로직 필요

### 결정

**옵션 1 채택**: 초기 구현에서는 환경 변수로 관리하고, 향후 사용자별 알림 설정이 필요할 때 데이터베이스로 전환.

### 근거

1. **MVP 우선**: Phase 2 목표는 이메일 전송 기능 구현이므로 최소 기능으로 시작
2. **단순성**: 환경 변수만 설정하면 즉시 사용 가능
3. **개인 프로젝트 특성**: 초기에는 개발자 본인 또는 소수의 수신자만 필요
4. **환경별 설정**: 개발/프로덕션 환경에서 다른 수신자로 테스트 가능
5. **확장 가능성**: 향후 사용자 인증 시스템 구축 시 데이터베이스로 전환 가능

### 결과

- `NOTIFICATION_EMAIL_FROM`: 보내는 사람 이메일 주소 (환경 변수)
- `NOTIFICATION_EMAIL_TO`: 받는 사람 이메일 주소 (쉼표로 구분된 여러 주소, 환경 변수)
- 향후 사용자별 알림 설정을 위한 주석 추가

### 향후 전환 계획

사용자별 알림 설정이 필요할 때:
1. `user_notification_preferences` 테이블 생성
2. 사용자별 알림 채널(이메일/푸시) 및 조건 설정
3. ETL에서 사용자별 설정 조회 후 알림 전송
4. 환경 변수는 기본/폴백 수신자로 사용

---

## ADR-011: 이메일 전송 방식 - 개별 전송 vs 종합 전송

**날짜**: 2025-12-03  
**상태**: ✅ 채택  
**결정자**: 개발팀  
**단계**: 구현

### 상황

감지된 알림을 이메일로 전송할 때, 종목마다 개별 이메일을 보낼지, 아니면 여러 종목을 하나의 이메일로 종합해서 보낼지 결정해야 했습니다.

### 고려 사항

**옵션 1**: 종목마다 개별 이메일 전송
- ✅ 각 종목별로 독립적인 알림
- ✅ 특정 종목만 필터링 가능
- ❌ 여러 종목 감지 시 이메일 스팸 가능성
- ❌ 이메일 서비스 비용 증가 (Resend 무료 티어 제한)
- ❌ 수신자 입장에서 이메일 과다

**옵션 2**: 여러 종목을 하나의 이메일로 종합 전송 (최종 결정)
- ✅ 이메일 수 감소 (비용 절감)
- ✅ 수신자 입장에서 한눈에 파악 가능
- ✅ 이메일 서비스 제한에 효율적
- ❌ 개별 종목 필터링 어려움 (하지만 HTML에서 확인 가능)

### 결정

**옵션 2 채택**: 여러 알림을 하나의 종합 이메일로 전송.

### 근거

1. **비용 효율성**: Resend 무료 티어 제한(월 3,000건) 고려 시 종합 전송이 효율적
2. **사용자 경험**: 여러 종목을 한 번에 확인하는 것이 더 편리
3. **확장성**: 향후 알림 종류가 늘어나도 하나의 이메일로 관리 가능
4. **구현 단순성**: 배치 전송 함수 하나로 처리 가능

### 결과

- `sendEmailAlertBatch()` 함수 구현
- 여러 알림을 하나의 HTML 이메일로 종합
- 제목: `[스크리너 알림] N개 종목 20일선 돌파 감지`
- 테이블 형태로 종합 정보 제공 (티커, 종목명, 섹터, 종가, 20일선, 시가총액, 돌파율, 전일대비, 거래량변동)
- 각 행 클릭 시 해당 종목 상세 페이지로 이동

---

## ADR-012: 이메일 템플릿 정보 확장

**날짜**: 2025-12-03  
**상태**: ✅ 채택  
**결정자**: 개발팀  
**단계**: 구현

### 상황

초기 이메일 템플릿에는 기본적인 정보만 포함되어 있었습니다. 사용자 피드백을 통해 더 유용한 정보를 추가하기로 결정했습니다.

### 추가된 정보

1. **섹터**: 종목의 산업 분류 정보
2. **20일선 가격**: 돌파 기준선을 명확히 표시
3. **시가총액**: 종목 규모 파악 (B/M/K 단위로 포맷팅)
4. **전일 대비 종가 변동률**: 가격 움직임 파악
5. **거래량 변동률**: 돌파의 신뢰도 판단

### 결정

모든 제안된 정보를 이메일 테이블에 추가.

### 근거

1. **20일선 가격**: 돌파 기준선을 명시하여 돌파 여부를 빠르게 파악 가능
2. **시가총액**: 대형주/중형주/소형주 구분으로 투자 결정에 유용
3. **전일 대비 변동률**: 돌파와 함께 가격 움직임을 종합적으로 파악
4. **거래량 변동률**: 거래량 증가는 돌파의 신뢰도를 높이는 지표
5. **섹터**: 산업별 분류로 포트폴리오 다각화 고려 가능

### 결과

- `AlertData` 타입에 필드 추가 (`sector`, `marketCap`, `todayVolume`, `prevVolume`, `priceChangePercent`, `volumeChangePercent`)
- SQL 쿼리에서 필요한 데이터 조회 및 계산
- 이메일 템플릿 테이블에 9개 컬럼 표시
- 시가총액 포맷팅 함수 구현 (`formatMarketCap`)
- 색상 코딩: 전일대비/거래량변동은 양수/음수에 따라 색상 구분

---

## ADR-013: 외부 API 호출 타임아웃 및 재시도 로직 추가

**날짜**: 2025-12-03  
**상태**: ✅ 채택  
**결정자**: 개발팀  
**단계**: 코드 리뷰 후 개선

### 상황

코드 리뷰에서 Resend API 호출에 타임아웃 및 재시도 로직이 없음이 지적되었습니다. 코딩 가이드라인에 따르면 "모든 외부 API 호출에는 타임아웃 처리와 지수 백오프를 사용한 재시도 로직이 포함되어야 합니다."

### 고려 사항

**옵션 1**: 재시도 로직 없이 현재 상태 유지
- ✅ 단순성 유지
- ❌ 일시적인 네트워크 문제나 서비스 장애 시 실패
- ❌ 코딩 가이드라인 위반

**옵션 2**: 기존 재시도 유틸리티 활용 (최종 결정)
- ✅ 프로젝트에 이미 `apps/web/src/etl/utils/retry.ts` 유틸리티 존재
- ✅ 일관된 재시도 로직 사용
- ✅ 타임아웃, 지수 백오프, 지터 모두 포함
- ✅ 재시도 가능한 에러 자동 판별

**옵션 3**: 새로운 재시도 로직 구현
- ❌ 기존 유틸리티와 중복
- ❌ 유지보수 부담 증가

### 결정

**옵션 2 채택**: 기존 `retryApiCall` 유틸리티를 활용하여 이메일 전송에 타임아웃 및 재시도 로직을 추가합니다.

### 근거

1. **코딩 가이드라인 준수**: `docs/CODE_REVIEW_CHECKLIST.md`에 명시된 "I/O·네트워크·DB는 재시도/타임아웃 등으로 보호되는가?" 요구사항 충족
2. **기존 인프라 활용**: 프로젝트에 이미 검증된 재시도 유틸리티가 존재하므로 재사용
3. **안정성 향상**: 일시적인 네트워크 문제나 서비스 장애 시 자동 재시도로 성공률 향상
4. **일관성**: 다른 API 호출(Gemini API 등)과 동일한 패턴 사용

### 결과

- `apps/web/src/lib/notifications/email.ts`에 `retryApiCall` 적용
- 타임아웃: 10초 (`EMAIL_SEND_TIMEOUT_MS = 10_000`)
- 재시도 설정:
  - 최대 시도 횟수: 3회
  - 기본 지연: 1초
  - 최대 지연: 5초
  - 지수 백오프 배수: 2
  - 지터: 활성화
- `Promise.race`를 사용한 타임아웃 래퍼 구현
- Resend API 에러 응답 처리 (`result.error` 확인)
- 테스트 코드에 `retryApiCall` 모킹 추가

---

## 향후 의사결정 예상 항목

### ADR-010 (예정): 비동기 큐 전환

**예상 시점**: 이메일 전송량 증가 시

**고려 사항**:
- ETL 실행 시간 증가
- 재시도 로직 필요성
- 배치 처리 필요성

**예상 결정**: BullMQ 또는 Redis Queue 도입

---

## 의사결정 프로세스

1. **상황 파악**: 문제 또는 선택지 명확히 정의
2. **옵션 나열**: 가능한 모든 옵션과 장단점 정리
3. **근거 수립**: 프로젝트 원칙, 일관성, 실용성 등을 고려
4. **결정 문서화**: ADR 형식으로 기록
5. **결과 추적**: 결정 후 실제 결과 확인 및 필요 시 수정

## 참고 자료

- [ADR 템플릿](https://adr.github.io/)
- 프로젝트 원칙: `docs/CODE_REVIEW_CHECKLIST.md`
- Phase 1 의사결정: `.specify/specs/price-alert-notifications/decisions.md` (통합 문서)

